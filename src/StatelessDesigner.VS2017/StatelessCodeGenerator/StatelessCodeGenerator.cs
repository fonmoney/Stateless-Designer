using System;
using System.ComponentModel.Design;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.TextTemplating.VSHost;
using StatelessXml;
using VSLangProj80;
using EnvDTE;
using Microsoft.VisualStudio.Shell.Interop;

namespace StatelessCodeGenerator
{
  [ComVisible(true)]
  [ClassInterface(ClassInterfaceType.None)]
  [Guid("A4008ECD-02C6-418F-A0BD-083461479064")]
  [CodeGeneratorRegistration(typeof(StatelessCodeGenerator),
      "Stateless Designer",
      vsContextGuids.vsContextGuidVCSProject,
      GeneratesDesignTimeSource = true)]
  [ProvideObject(typeof(StatelessCodeGenerator))]
  public class StatelessCodeGenerator : BaseCodeGeneratorWithSite
  {
    public override string GetDefaultExtension()
    {
      return ".cs";
    }

    protected override byte[] GenerateCode(string inputFileName, string inputFileContent)
    {
      try
      {
        var xmlParser = XmlParser.Parse(inputFileContent);

        if (xmlParser == null)
        {
            return Encoding.ASCII.GetBytes("// no statemachine could be found; no code is generated" +
                                           Environment.NewLine);
        }

        var itemname = xmlParser.ItemName;
        var ns = xmlParser.NameSpace;
        var triggers = xmlParser.Triggers;
        var states = xmlParser.States;
        var startstate = xmlParser.StartState;
        var transitions = xmlParser.Transitions;
        var triggerTypeName = xmlParser.TriggerTypeName ?? "Trigger";
        var stateTypeName = xmlParser.StateTypeName ?? "State";
                
        var sb = new StringBuilder();
        sb.Append(
          "// IMPORTANT: THIS IS MACHINE-GENERATED CODE" + Environment.NewLine +
          "// PLEASE DO NOT EDIT" + Environment.NewLine +
          "// Generated by Stateless Designer" + Environment.NewLine +
          "// https://github.com/frederiksen/Stateless-Designer" + Environment.NewLine +
          Environment.NewLine +
          "using Stateless;" + Environment.NewLine +
          Environment.NewLine
          );
        sb.Append("namespace ");
        sb.Append(ns);
        sb.Append(Environment.NewLine);
        sb.Append("{" + Environment.NewLine);
        sb.Append("  ");
        sb.Append(xmlParser.ClassType);
        sb.AppendLine($" partial class {itemname}");
        sb.AppendLine("  {");

        if (xmlParser.TriggerTypeName == null)
        {
            sb.Append(
                "    public enum Trigger" + Environment.NewLine +
                "    {" + Environment.NewLine
            );
            sb.Append(triggers.Aggregate("",
                (current, trigger) =>
                    current + ("      " + trigger + "," + Environment.NewLine)));
            sb.Append("    }" + Environment.NewLine + Environment.NewLine);
        }

        if (xmlParser.StateTypeName == null)
        {
            sb.Append(
                "    public enum State" + Environment.NewLine +
                "    {" + Environment.NewLine
            );
            sb.Append(states.Aggregate("",
                (current, state) =>
                    current + ("      " + state + "," + Environment.NewLine)));
            sb.Append("    }" + Environment.NewLine + Environment.NewLine);
        }

        foreach (var state in states)
        {
          sb.Append("    partial void On");
          sb.Append(state);
          sb.Append("Entry();" + Environment.NewLine);
          sb.Append("    partial void On");
          sb.Append(state);
          sb.Append("Exit();" + Environment.NewLine);
        }
        foreach (var state in states)
        {
          var tr = from t in transitions
                   where t.From == state
                   select t;
          foreach (var t in tr)
          {
            sb.AppendLine($"    partial void GuardClauseFrom{t.From}To{t.To}Via{t.Trigger}(ref bool permit);");
          }
        }
        sb.AppendLine($"    partial void OnUnhandledTrigger({stateTypeName} state, {triggerTypeName} trigger);");

        sb.AppendLine();
        sb.Append($"    protected StateMachine<{stateTypeName}, {triggerTypeName}> stateMachine =");
        sb.AppendLine($" new StateMachine<{stateTypeName}, {triggerTypeName}>({stateTypeName}.{startstate});");
        sb.AppendLine();
        sb.AppendLine($"    protected void ConfigureStateMachine()");
        sb.AppendLine("    {");

        foreach (var state in states)
        {
          sb.AppendLine($"      stateMachine.Configure({stateTypeName}.{state})");
          sb.AppendLine($"        .OnEntry(() => On{state}Entry())");
          sb.AppendLine($"        .OnExit(() => On{state}Exit())");

          var tr = from t in transitions
                   where t.From == state
                   select t;
          foreach (var t in tr)
          {
            var guardMethodCall = $"GuardClauseFrom{t.From}To{t.To}Via{t.Trigger}(ref permit)";
            if (state == t.To)
            {
              sb.Append($"        .PermitReentryIf({triggerTypeName}.{t.Trigger}, ");
            }
            else
            {
              sb.Append($"        .PermitIf({triggerTypeName}.{t.Trigger}, {stateTypeName}.{t.To} , ");
            }
            sb.Append($"() => {{ var permit = true; {guardMethodCall}; return permit; }}");
            sb.AppendLine(")");
          }
          sb.Append("      ;" + Environment.NewLine);

        }
        sb.Append("      stateMachine.OnUnhandledTrigger((state, trigger) => { OnUnhandledTrigger(state, trigger); });" + Environment.NewLine);
        sb.AppendLine("    }");
        sb.AppendLine("  }");
        sb.AppendLine("}");

        return Encoding.ASCII.GetBytes(sb.ToString());
      }
      catch (Exception ex)
      {
        return Encoding.ASCII.GetBytes(ex.Message);
      }
    }
  }
}